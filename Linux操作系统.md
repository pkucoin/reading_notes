# 目标
作为一个后端程序员，应该对自己所写程序运行的操作系统有所了解。这种了解可以分为两个层次：
1. 了解操作系统的构成、结构及提供的系统调用，以便能够使用操作系统提供的功能；
2. 了解操作系统构成、结构、系统调用背后的实现原理是什么样的，以便在使用操作系统提供的功能时能够有所选择、有所取舍，并对可能出现的性能问题、非期望结果能够有所解释和改进。

# 参考文献
阅读书籍以《Linux Programming Interface》为主，APUE为辅。相比APUE，LPI的突出优点有两点：
- LPI都是围绕Linux来讲解的，而APUE则是围绕UNIX，附带讲解Linux的。
- LPI在很多topic上深入讲解了Linux的具体实现和实际用法。

# 文件IO

## 文件描述符
Linux使用文件描述符（file descriptor, fd）这样一个非负整数来指代所有执行IO操作的文件。这里，文件并不仅仅限于磁盘文件，也包括pipe、fifo、socket、terminal、device等。

关于文件描述符与打开的文件之间的关系，内核维护了3个数据结构:
- 进程级的文件描述符表
- 系统级的打开文件表
- 文件系统级的i-node表

![文件描述符、打开的文件句柄和i-node之间的关系](https://github.com/pkucoin/reading_notes/blob/master/pics/%E6%96%87%E4%BB%B6%E6%8F%8F%E8%BF%B0%E7%AC%A6%E3%80%81%E6%89%93%E5%BC%80%E7%9A%84%E6%96%87%E4%BB%B6%E5%8F%A5%E6%9F%84%E5%92%8Ci-node%E4%B9%8B%E9%97%B4%E7%9A%84%E5%85%B3%E7%B3%BB.JPG "文件描述符、打开的文件句柄和i-node之间的关系")

显然，不同进程中相同的fd可以指向不同的文件，而不同的fd也可以指向同一个文件，它们将共享该文件的偏移量和打开文件标志，但fd的close-on-exec标志仍为进程所私有。在shell中0, 1, 2这三个fd始终是打开的，依次用于标准输入、标准输出和标准错误，所以程序也继承了这三个fd。

一个fd可以通过dup系统调用得到它的一个复制fd，该复制fd与原fd指向同一个打开的文件句柄。dup2可以指定返回的复制fd的值，dup3可以指定返回的复制fd的close-on_exec标志。

## 通用IO系统调用
四个系统调用open(), read(), write(), close()具有通用性，可以对所有类型的fd执行相应的IO操作。

