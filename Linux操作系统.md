# 目标
作为一个后端程序员，应该对自己所写程序运行的操作系统有所了解。这种了解可以分为两个层次：
1. 了解操作系统的构成、结构及提供的系统调用，以便能够使用操作系统提供的功能；
2. 了解操作系统构成、结构、系统调用背后的实现原理是什么样的，以便在使用操作系统提供的功能时能够有所选择、有所取舍，并对可能出现的性能问题、非期望结果能够有所解释和改进。

# 参考文献
阅读书籍以《Linux Programming Interface》为主，APUE和《现代操作系统（第3版）》为辅。相比APUE，LPI的突出优点有两点：
- LPI都是围绕Linux来讲解的，而APUE则是围绕UNIX，附带讲解Linux的。
- LPI在很多topic上深入讲解了Linux的具体实现和实际用法。不过在一些原理问题上不如《现代操作系统》详细。

# 内核概览
![Linux内核结构](https://github.com/pkucoin/reading_notes/blob/master/pics/Linux%E5%86%85%E6%A0%B8%E7%BB%93%E6%9E%84.JPG "Linux内核结构")

内核坐落在硬件之上，负责实现与IO设备、存储管理单元的交互，并控制CPU对前述设备的访问。可以将内核分为三个主要部件：
- 进程管理：负责进程/线程的创建、终止和调度，以及信号的处理。
- 内存管理：采用虚拟内存管理机制管理对RAM资源的使用
- I/O管理：实现与终端、套接字、文件系统等的I/O功能

执行硬件指令可以使现代CPU在用户态和核心态之间切换运行。只有运行在内核时，CPU才能访问虚拟内存空间中的内核空间内存，并执行部分特定指令。Linux内核始终运行在CPU的核心态。内核通过向用户进程提供系统调用接口，使得用户进程可以执行特定的只有内核态才能完成的任务，同时不会危害到系统运行的安全。系统调用接口的wrapper函数会将系统调用编号和调用参数复制到寄存器，然后执行一条特殊指令（INT80/sysenter/syscall，具体过程和区别可以参考[文章](https://www.jianshu.com/p/f4c04cf8e406)）引发从用户态到核心态的切换，内核开始执行系统调用编号对应的程序，最后返回到用户态中，并由wrapper函数返回执行结果给调用程序。

# 进程与线程

## 进程概述
进程是内核定义的抽象实体，由用户内存空间和一系列内核数据结构组成，由内核负责为该实体分配用以执行程序的各项系统资源。其中用户内存空间包含了程序代码和变量，内核数据结构则用于内核维护进程状态信息，记录各类标识号、虚拟内存表、文件描述符表、信号处理、进程资源使用及限制、当前工作目录等。

# 文件I/O

## 文件描述符
Linux使用文件描述符（file descriptor, fd）这样一个非负整数来指代所有执行IO操作的文件。这里，文件并不仅仅限于磁盘文件，也包括pipe、fifo、socket、terminal、device等。

关于文件描述符与打开的文件之间的关系，内核维护了3个数据结构:
- 进程级的文件描述符表
- 系统级的打开文件表
- 文件系统级的i-node表

![文件描述符、打开的文件句柄和i-node之间的关系](https://github.com/pkucoin/reading_notes/blob/master/pics/%E6%96%87%E4%BB%B6%E6%8F%8F%E8%BF%B0%E7%AC%A6%E3%80%81%E6%89%93%E5%BC%80%E7%9A%84%E6%96%87%E4%BB%B6%E5%8F%A5%E6%9F%84%E5%92%8Ci-node%E4%B9%8B%E9%97%B4%E7%9A%84%E5%85%B3%E7%B3%BB.JPG "文件描述符、打开的文件句柄和i-node之间的关系")

显然，不同进程中相同的fd可以指向不同的文件，而不同的fd也可以指向同一个文件，它们将共享该文件的偏移量和打开文件状态标志，但fd的close-on-exec标志仍为进程所私有。在shell中0, 1, 2这三个fd始终是打开的，依次用于标准输入、标准输出和标准错误，所以程序也继承了这三个fd。

一个fd可以通过dup系统调用得到它的一个复制fd，该复制fd与原fd指向同一个打开的文件句柄。dup2可以指定返回的复制fd的值，dup3可以指定返回的复制fd的close-on_exec标志。

## 通用IO系统调用
四个系统调用open(), read(), write(), close()具有通用性，可以对所有类型的fd执行相应的IO操作。

### 打开文件open()
open调用的flags分为
- 访问模式标志：取O_RDONLY, O_WRONLY, ORDWR三者中的一个，注意读写并不是前两者相与的关系
- 文件创建标志：设定文件创建相关的选项
- 打开文件状态标志：设定进行文件IO操作时的选项

open()的标志位可以用来保证相关文件操作的原子性。例如：
- 同时指定O_EXCL和O_CREAT作为标志位，可以保证对文件是否存在和创建文件纳入同一原子操作，从而保证本进程是打开文件的创建者，如果文件已经存在则返回错误。
- 指定O_APPEND标志可以将文件偏移量的移动和数据写操作纳入同一原子操作，从而保证多个进程/线程同时向同一个文件尾部添加数据时不会产生交叠。[多线程网络库handy](https://github.com/yedf/handy)的日志就是这么做的。

### 读取数据read()
read()读取的是字节流，并不区分读取数据的类型，故如果读取的是字符串，需要自己在结尾处显式追加一个'\0'。

readv()调用实现了从文件中读取连续字节后**原子地**分散放置在若干个缓冲区内的功能。

### 写入数据write()
write()调用成功并不意味这数据已经写入了磁盘（见文件IO缓冲部分）。write()出现部分写的可能原因是磁盘已满或者文件大小超过RLIMIT_FSIZE。

writev()调用实现了将若干个缓冲区内的数据**原子地**连续写入文件的功能。

### 关闭文件close()
文件描述符是有限资源，关闭失败可能会导致文件描述符资源消耗殆尽，故应该对close()的返回值进行错误检查。

### 改变文件偏移量lseek()

文件偏移量是打开文件句柄（而不是文件描述符）的属性。如果多个线程对同一文件描述符或者指向同一打开文件句柄的不同文件描述符同时进行操作，文件偏移量会在这些线程间共享，改变也会对这些线程可见，这会造成race condition。pread()和pwrite()调用可以在不改变文件当前偏移量的情况下进行指定位置的文件IO。

文件偏移量可以被设定为大于文件的当前长度，这种情况下一次write()会造成之前长度到当前偏移量之间形成以0填充的空洞。如果read()这些位置会读取到0，但空洞并不占用磁盘空间。在文件系统部分进行相关讨论。

## 文件IO缓冲
read()和write()系统调用并不直接发起磁盘访问，而是在用户空间缓冲区和内核缓冲区cache之间复制数据。
write()调用在将数据从stdio缓冲区传递到内核缓冲区后立即返回，在之后某个时刻内核负责将内核缓冲区中的数据真正写回硬盘中。如果此时有其他进程试图读取该文件内容，则内核会从缓冲区提供这些（还未写回硬盘的）数据，而不是返回此时已经过期还未刷新的硬盘文件中的内容。
read()调用会从内核缓冲区读取数据，内核会在缓冲区数据读取完之前就尝试将文件的下一数据块读入内核缓冲区。

在文件IO缓冲的设计下，使read()和write()调用无需等待磁盘操作，同时也减少了磁盘操作次数，因而极大提高了文件IO的效率。

![文件IO缓冲结构](https://github.com/pkucoin/reading_notes/blob/master/pics/%E6%96%87%E4%BB%B6IO%E7%BC%93%E5%86%B2.JPG "文件IO缓冲结构")

图中列出了数据在用户和磁盘之间经历的传输过程。左侧依次列出了要使数据从stdio缓冲区强制刷新到内核缓冲区的fflush()调用和使数据从内核缓冲区刷新到磁盘的fsync(fd)(强制包含元数据), fdatasync(fd)（无需包含元数据）和sync(void)（整个内核缓冲区）操作。右侧则列出了使得上述两个过程自动刷新的setbuf和open()的O_SYNC标志（非常耗）。

只有在特定需求下，例如自带高速缓存和IO优化的数据库系统，才会绕过IO缓冲区直接进行IO。否则会带来严重的IO性能问题。

# 文件系统
文件系统是对常规文件和目录的组织集合，为应用程序进行文件操作提供接口。

## 虚拟文件系统VFS
Linux通过虚拟文件系统VFS在应用程序和文件系统之间创建了一个抽象层，以达到支持众多种类的文件系统的同时应用程序无需理解每一种文件系统的操作差异的目的。

## ext2文件系统
