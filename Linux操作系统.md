# 目标
作为一个后端程序员，应该对自己所写程序运行的操作系统有所了解。这种了解可以分为两个层次：
1. 了解操作系统的构成、结构及提供的系统调用，以便能够使用操作系统提供的功能；
2. 了解操作系统构成、结构、系统调用背后的实现原理是什么样的，以便在使用操作系统提供的功能时能够有所选择、有所取舍，并对可能出现的性能问题、非期望结果能够有所解释和改进。

# 参考文献
阅读书籍以《Linux Programming Interface》为主，APUE和《现代操作系统（第3版）》为辅。相比APUE，LPI的突出优点有两点：
- LPI都是围绕Linux来讲解的，而APUE则是围绕UNIX，附带讲解Linux的。
- LPI在很多topic上深入讲解了Linux的具体实现和实际用法。不过在一些原理问题上不如《现代操作系统》详细。

# 内核概览
![Linux内核结构](https://github.com/pkucoin/reading_notes/blob/master/pics/Linux%E5%86%85%E6%A0%B8%E7%BB%93%E6%9E%84.JPG "Linux内核结构")

内核坐落在硬件之上，负责实现与IO设备、存储管理单元的交互，并控制CPU对前述设备的访问。可以将内核分为三个主要部件：
- 进程管理：负责进程/线程的创建、终止和调度，以及信号的处理。
- 内存管理：采用虚拟内存管理机制管理对RAM资源的使用
- I/O管理：实现与终端、套接字、文件系统等的I/O功能

执行硬件指令可以使现代CPU在用户态和核心态之间切换运行。只有运行在核心态时，CPU才能访问虚拟内存空间中的内核空间内存以及执行部分特定指令。Linux内核始终运行在CPU的核心态。内核通过向用户进程提供系统调用接口，使得用户进程可以执行特定的只有内核态才能完成的任务，同时不会危害到系统运行的安全。系统调用接口的wrapper函数会将系统调用编号和调用参数复制到寄存器，然后执行一条特殊指令（INT80/sysenter/syscall，具体过程和区别可以参考[文章](https://www.jianshu.com/p/f4c04cf8e406)）引发从用户态到核心态的切换，内核开始执行系统调用编号对应的程序，执行之后再切换到用户态中，并由wrapper函数返回执行结果给调用程序。

# 虚拟内存机制

虚拟内存提供了一个对进程透明的内存资源分配和管理机制。其要点包括：
- 虚拟内存是对物理内存和部分磁盘扩充的抽象
- 进程使用虚拟内存地址而非物理地址，内核负责两者之间的转换
- 段页式内存管理机制

具体来说，虚拟内存将内存分割为固定大小的页（常见的大小是4096字节），物理内存被划分为一系列该大小的页帧。物理内存在虚拟内存机制中可以被看做一个cache。每个进程最近使用到的部分页驻留在物理内存中，称为驻留集resident set；未使用到的部分保存在磁盘的swap area中。进程运行时使用虚拟内存地址，CPU的MMU会通过查询内存中的页表得到对应的物理地址。如果进程要访问的页不在物理内存中，则发生一次缺页中断page fault，内核挂起当前进程，将该页从磁盘中载入物理内存。



# 进程与线程

## 进程概述
进程是内核定义的抽象实体，由用户内存空间和一系列内核数据结构组成，由内核负责为该实体分配用以执行程序的各项系统资源。其中用户内存空间包含了程序代码和变量，内核数据结构则用于内核维护进程状态信息，记录各类标识号、虚拟内存表、文件描述符表、信号处理、进程资源使用及限制、当前工作目录等。

内核使用进程号PID来唯一标识进程号，可以通过getpid()系统调用(虽然getpid仅仅返回一个整数，但作为一个系统调用仍然有其)来获取。在用户进程被创建时，其进程号会被取为300（小于300的进程号被系统进程和守护进程占用）到pid_max - 1之间可用且最小的整数。故任意时刻不存在PID相同的进程，但是不同时刻同一PID可能是不同进程。每个进程都有父进程，可以通过getppid()系统调用来获取。所有进程间因此形成了树状结构，根是进程号为1的init进程，可以使用pstree来获取该结构。

内核维护了PID到对应进程描述符的映射。进程描述符是类型为task_struct的内核进程数据结构，描述了进程的各类属性，主要包括：
- 进程地址空间：指向文本段、数据段、堆栈段等的指针。
- 进程标识符及凭证：pid, ppid, pgid, uid, euid等。
- 文件：打开的文件fd、打开文件状态标志、文件偏移、close-on-exec标志、工作目录等
- 信号：信号设定和处理信息
- 定时器：定时器设定和处理信息
- 线程：线程、互斥量和条件变量
- 进程间通信：各类IPC信息
- 其他：资源统计信息、资源限制等


## 进程内存布局

## 进程创建
创建进程的过程实际上就是为子进程创建一个进程描述符以及用户内存空间的过程。其中进程描述符的内容大多根据父进程的内容进行复制，用户内存空间的大部分也共享或复制自父进程。下面以fork()调用为主介绍进程创建的细节，然后介绍fork(), vfork(), clone()之间的异同。

fork()调用创建一个新的子进程，该子进程几乎是调用进程的翻版。子进程会与父进程共享文本段（文本段是只读的，故没有复制的必要），并拷贝数据段及堆栈段。由于fork()调用之后常常伴随exec()来执行另一个程序，这会重新初始化数据段及堆栈段，故内核使用写时复制（copy-on-write）技术来避免不必要的复制造成的浪费。内核会先将子进程的页表项指向与父进程相同的物理页，然后捕获父进程和子进程中所有试图修改这些页面的操作，在修改前真正执行拷贝操作，并调整子进程对应的页表项。在此之后，父子进程各自修改其数据段及堆栈段互不影响。

fork()的名字形象地表明了其行为：子进程和父进程将在fork()之后“分叉”，分别在fork()的返回处继续执行。fork()执行成功返回时，在父进程中的返回值是子进程的pid，而在子进程中的返回值则是0。执行失败时将返回-1，可能的原因是已创建进程数量超过了系统限制。在Linux上，fork()返回后首先调度执行的是父进程还是子进程取决于/rpoc/sys/kernel/sched_child_runs_first，从2.6.32开始该值为0，意味着父进程将首先被调度执行。但不应该对这一顺序做任何假定，如果需要保证特定的执行顺序，应该明确使用某种同步技术，否则可能产生race condition。

由于早期的fork()会对父进程的数据段和堆栈段进行严格的复制，效率较低，因此引入了vfork()调用。vfork()创建的子进程与父进程共享内存空间（父子进程任何一方对内存的修改都会对对方可见），直到执行了exec()或_exit()退出，在此之前会暂停执行父进程。vfork()几乎只有一种正确用法，即调用vfork()之后马上调用exec()，调用exec()或_exit()之前调用任何其他函数或者修改任何变量值都是UB。事实上，使用写时复制的fork()与vfork()效率已经没有明显差别，vfork()已经被SUSv3标为deprecated并从SUSv4中剔除。

clone()调用是Linux平台特有的，提供了细致的标志位来控制进程创建的具体过程。


## 等待子进程

## 进程退出

# 文件I/O

## 文件描述符
Linux使用文件描述符（file descriptor, fd）这样一个非负整数来指代所有执行IO操作的文件。这里，文件并不仅仅限于磁盘文件，也包括pipe、fifo、socket、terminal、device等。

关于文件描述符与打开的文件之间的关系，内核维护了3个数据结构:
- 进程级的文件描述符表
- 系统级的打开文件表
- 文件系统级的i-node表

![文件描述符、打开的文件句柄和i-node之间的关系](https://github.com/pkucoin/reading_notes/blob/master/pics/%E6%96%87%E4%BB%B6%E6%8F%8F%E8%BF%B0%E7%AC%A6%E3%80%81%E6%89%93%E5%BC%80%E7%9A%84%E6%96%87%E4%BB%B6%E5%8F%A5%E6%9F%84%E5%92%8Ci-node%E4%B9%8B%E9%97%B4%E7%9A%84%E5%85%B3%E7%B3%BB.JPG "文件描述符、打开的文件句柄和i-node之间的关系")

显然，不同进程中相同的fd可以指向不同的文件，而不同的fd也可以指向同一个文件，它们将共享该文件的偏移量和打开文件状态标志，但fd的close-on-exec标志仍为进程所私有。在shell中0, 1, 2这三个fd始终是打开的，依次用于标准输入、标准输出和标准错误，所以程序也继承了这三个fd。

一个fd可以通过dup系统调用得到它的一个复制fd，该复制fd与原fd指向同一个打开的文件句柄。dup2可以指定返回的复制fd的值，dup3可以指定返回的复制fd的close-on_exec标志。

## 通用IO系统调用
四个系统调用open(), read(), write(), close()具有通用性，可以对所有类型的fd执行相应的IO操作。

### 打开文件open()
open调用的flags分为
- 访问模式标志：取O_RDONLY, O_WRONLY, ORDWR三者中的一个，注意读写并不是前两者相与的关系
- 文件创建标志：设定文件创建相关的选项
- 打开文件状态标志：设定进行文件IO操作时的选项

open()的标志位可以用来保证相关文件操作的原子性。例如：
- 同时指定O_EXCL和O_CREAT作为标志位，可以保证对文件是否存在和创建文件纳入同一原子操作，从而保证本进程是打开文件的创建者，如果文件已经存在则返回错误。
- 指定O_APPEND标志可以将文件偏移量的移动和数据写操作纳入同一原子操作，从而保证多个进程/线程同时向同一个文件尾部添加数据时不会产生交叠。[多线程网络库handy](https://github.com/yedf/handy)的日志就是这么做的。

### 读取数据read()
read()读取的是字节流，并不区分读取数据的类型，故如果读取的是字符串，需要自己在结尾处显式追加一个'\0'。

readv()调用实现了从文件中读取连续字节后**原子地**分散放置在若干个缓冲区内的功能。

### 写入数据write()
write()调用成功并不意味这数据已经写入了磁盘（见文件IO缓冲部分）。write()出现部分写的可能原因是磁盘已满或者文件大小超过RLIMIT_FSIZE。

writev()调用实现了将若干个缓冲区内的数据**原子地**连续写入文件的功能。

### 关闭文件close()
文件描述符是有限资源，关闭失败可能会导致文件描述符资源消耗殆尽，故应该对close()的返回值进行错误检查。

### 改变文件偏移量lseek()

文件偏移量是打开文件句柄（而不是文件描述符）的属性。如果多个线程对同一文件描述符或者指向同一打开文件句柄的不同文件描述符同时进行操作，文件偏移量会在这些线程间共享，改变也会对这些线程可见，这会造成race condition。pread()和pwrite()调用可以在不改变文件当前偏移量的情况下进行指定位置的文件IO。

文件偏移量可以被设定为大于文件的当前长度，这种情况下一次write()会造成之前长度到当前偏移量之间形成以0填充的空洞。如果read()这些位置会读取到0，但空洞并不占用磁盘空间。在文件系统部分进行相关讨论。

## 文件IO缓冲
read()和write()系统调用并不直接发起磁盘访问，而是在用户空间缓冲区和内核缓冲区cache之间复制数据。
write()调用在将数据从stdio缓冲区传递到内核缓冲区后立即返回，在之后某个时刻内核负责将内核缓冲区中的数据真正写回硬盘中。如果此时有其他进程试图读取该文件内容，则内核会从缓冲区提供这些（还未写回硬盘的）数据，而不是返回此时已经过期还未刷新的硬盘文件中的内容。
read()调用会从内核缓冲区读取数据，内核会在缓冲区数据读取完之前就尝试将文件的下一数据块读入内核缓冲区。

在文件IO缓冲的设计下，使read()和write()调用无需等待磁盘操作，同时也减少了磁盘操作次数，因而极大提高了文件IO的效率。

![文件IO缓冲结构](https://github.com/pkucoin/reading_notes/blob/master/pics/%E6%96%87%E4%BB%B6IO%E7%BC%93%E5%86%B2.JPG "文件IO缓冲结构")

图中列出了数据在用户和磁盘之间经历的传输过程。左侧依次列出了要使数据从stdio缓冲区强制刷新到内核缓冲区的fflush()调用和使数据从内核缓冲区刷新到磁盘的fsync(fd)(强制包含元数据), fdatasync(fd)（无需包含元数据）和sync(void)（整个内核缓冲区）操作。右侧则列出了使得上述两个过程自动刷新的setbuf和open()的O_SYNC标志（非常耗）。

只有在特定需求下，例如自带高速缓存和IO优化的数据库系统，才会绕过IO缓冲区直接进行IO。否则会带来严重的IO性能问题。

# 文件系统
文件系统是对常规文件和目录的组织集合，为应用程序进行文件操作提供接口。

## 虚拟文件系统VFS
Linux通过虚拟文件系统VFS在应用程序和文件系统之间创建了一个抽象层，以达到支持众多种类的文件系统的同时应用程序无需理解每一种文件系统的操作差异的目的。

## ext2文件系统
