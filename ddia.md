# 第一章 可靠性、可扩展性和可维护性

## 可靠性（Reliability）
- 系统在出现故障（fault）时仍然能正确完成功能的性能水平
- 故障通常是指系统的一部分偏离标准，而失效（failure）是系统整体停止服务
- 故障总会出错，故容错（fault-tolerant）的目标是防止因故障导致失效
- 故障的种类
  - 硬件故障。例如单块硬盘MTTF约10~50年。硬件故障通常是随机且相互独立的。应对：增加冗余
  - 软件错误。系统性错误，更容易关联从而导致系统失效。应对：测试；进程隔离，允许崩溃后重启；监控
  - 人为错误。应对：容易犯错的地方解耦；corner case测试；可以从人为错误中快速恢复；监控

## 可扩展性（Scalability）
- 系统应对负载增长的性能水平
- 使用负载参数，例如qps、读写次数、dau、cache命中率等等，来描述系统负载
  - Twitter的例子中，负载挑战来自于关注大量人/被大量人关注的用户
  - 使用push/pull混合策略来降低负载：对于粉丝量较少的人push其推文给粉丝；对于粉丝量巨大的人在粉丝上线时pull
- 使用性能参数，例如吞吐量、延迟/响应时间等等，来描述性能
  - 通常使用响应时间的百分点位来定义SLO/SLA中的预期性能/可用性
- 应对负载的方法
  - 纵向/垂直扩展：转向更强大的机器。代价是更贵
  - 横向/水平扩展：负载分布到更多机器。代价是有状态的数据系统从单节点变为分布式时会引入额外复杂度
  
## 可维护性（Maintainability）
- 系统让不同的人在不同的时期都能高效地在该系统上工作，使得系统正确工作并适应变化的水平
- 可操作性：让运维团队的日常工作可以更轻松。良好的监控/自动化

# 第二章 数据模型与查询语言
## 数据模型
- 一对多关系：文档模型更适合。关系模型中一对多关系需要拆分成多个表，获取时需要多表join，而文档模型可以一次性加载
- 多对一/多对多关系：关系模型更合适，天然支持join，而文档模型需要写代码来模拟join
- 文档模型拥有模式上的灵活性和查询时的数据局部性

## 数据查询语言
- 声明式查询语言相较于命令式查询语言有优势

# 第三章 存储与检索
## 索引
- 许多数据库使用append-only log存储数据
  - 数据量大到无法全部放入内存
  - 天然持久化
  - 文件尾部追加写入是非常高效的
- 索引
  - 为了高效查找数据库中特定键的值的一个附加结构
  - 基本思路是保存额外的元数据作为路标
  - 大大提高读取数据时的速度，但写入数据时需要更新
### 哈希索引
- 简单策略：使用hashmap在内存中记录所有键在log文件中的偏移量
  - 查询时，lseek到文件对应位置读取
- 实际应用中的问题
  - 使用日志合并log compaction避免追加写入用完磁盘空间：在后台线程中丢弃重复的键，只保留每个键最近的值
  - 使用二进制格式文件
  - 删除键值时，附加一个特殊的删除记录，在日志合并时放弃这个记录及以前该键的值
  - 重启时需要通过log文件恢复内存映射。可以保存hashmap映射来加快
  - 崩溃时可能含有部分写入的记录。使用校验和检测和忽略损坏部分
  - 每次修改都追加而不是更新文件中的值：顺序写入更快；更简单的并发和崩溃恢复
- 局限
  - hashmap大小必须能放入内存
  - 低效的范围查询
### SSTables和LSM树
- SSTables：按键排序的段文件
  - 简单高效的合并：使用多路归并，结果仍然保持有序（相同键保留最新的）
  - 不需要保存所有键的索引：


